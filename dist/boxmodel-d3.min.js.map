{"version":3,"sources":["webpack://boxmodel-d3/webpack/universalModuleDefinition","webpack://boxmodel-d3/webpack/bootstrap","webpack://boxmodel-d3/external \"d3\"","webpack://boxmodel-d3/./src/boxmodel.js"],"names":["root","factory","exports","module","require","define","amd","window","__WEBPACK_EXTERNAL_MODULE__0__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","boxmodel","d3__WEBPACK_IMPORTED_MODULE_0__","isContainer","spanHeight","vAlign","padding","margin","minContainerSize","maxLineWidth","nodeSize","edgeMargins","lineMap","compute","eachAfter","scaleNode","eachBefore","scaleToParent","positionNode","node","w","width","h","height","children","lines","lineWidth","flexHeight","startIndex","newLine","forEach","child","x1","x0","left","Math","max","right","marginRight","length","push","from","to","generateLines","calcLineHeight","box","d3","top","bottom","y0","y1","parent","getOwnLine","parentLines","getLines","lineIndex","getLineIndex","heightDiff","console","log","excess","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","iterator","next","done","err","return","order","indexOf","index","line","lineBreak","neighbourLeft","calcLineShift","lineHeight","childH","marginsVert","findIndex","arguments","include","lineTo","filter","constant","x"],"mappings":"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","file":"boxmodel-d3.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"d3\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"d3\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"boxmodel-d3\"] = factory(require(\"d3\"));\n\telse\n\t\troot[\"boxmodel-d3\"] = factory(root[\"d3\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE__0__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","import * as d3 from 'd3';\n\nexport default function boxmodel() {\n    // v.1.1.0 | by Peter Hofmann, 03/2019\n    \n    let isContainer,\n        spanHeight,\n        edgeMargins = false,\n        vAlign;\n    let padding,\n        margin,\n        minContainerSize,\n        maxLineWidth,\n        nodeSize;\n    const lineMap = [];\n    \n    function compute(root) {    \n      root.eachAfter(scaleNode);\n      root.eachBefore(scaleToParent);\n      root.eachBefore(positionNode);\n      \n      return root;\n    }\n    \n    compute.vAlign = function(x) {\n      return arguments.length ? (vAlign = x, compute) : vAlign;\n    };\n    compute.edgeMargins = function(x) {\n      return arguments.length ? (edgeMargins = x, compute) : edgeMargins;\n    };\n    compute.isContainer = function(x) {\n      return arguments.length ? (isContainer = typeof x === 'function' ? x : constant(+x), compute) : isContainer;\n    };\n    compute.spanHeight = function(x) {\n      return arguments.length ? (spanHeight = typeof x === 'function' ? x : constant(+x), compute) : spanHeight;\n    };\n    compute.padding = function(x) {\n      return arguments.length ? (padding = typeof x === 'function' ? x : constant(+x), compute) : padding;\n    };\n    compute.margin = function(x) {\n      return arguments.length ? (margin = typeof x === 'function' ? x : constant(+x), compute) : margin;\n    };\n    compute.nodeSize = function(x) {\n      return arguments.length ? (nodeSize = typeof x === 'function' ? x : constant(+x), compute) : nodeSize;\n    };\n    compute.minContainerSize = function(x) {\n      return arguments.length ? (minContainerSize = typeof x === 'function' ? x : constant(+x), compute) : minContainerSize;\n    };\n    compute.maxLineWidth = function(x) {\n      return arguments.length ? (maxLineWidth = typeof x === 'function' ? x : constant(+x), compute) : maxLineWidth;\n    };\n    \n    // --------------\n    // Main functions\n    \n    function scaleNode(node) {\n      // set size to fixed definition by default\n      let w = nodeSize(node).width, h = nodeSize(node).height;\n      \n      if (isContainer(node)) {\n        w = h = 0; // containers have no fixed size, so we nullify\n        \n        if (node.children) {\n          // For non-empty containers, size and margin between children must be summed up.\n          // To do this, we need to determine when a line of children widths/margins surpasses maxLineWidth\n          // and if so, add to an array that stores this line width as well as the interval of child indizes\n          const lines = generateLines(node);\n          // now loop through all lines and their elements to calculate the line heights\n          for (let l = 0; l < lines.length; l++) {\n            lines[l].height = calcLineHeight(node,lines,l); // add as line property\n          }\n          // add line array to a global line map\n          lineMap.push({box: node, lines: lines});\n          // add the largest of all line widths to the width\n          w += d3.max(lines, l => l.width);\n          // add the sum of all line heights to the height\n          h += d3.sum(lines, l => l.height);        \n        }\n        // no specified size => combined padding OR minSize (if paddings smaller)\n        w += padding(node).left + padding(node).right;\n        h += padding(node).top + padding(node).bottom;\n        w = Math.max(w, minContainerSize(node).width);\n        h = Math.max(h, minContainerSize(node).height);\n      }\n      \n      // finally, assign w/h to node coordinates\n      node.x0 = node.y0 = 0;\n      node.x1 = w, node.y1 = h;\n      \n    } // ------ end scaleNode() -------\n    \n    function scaleToParent(node) {\n      // spanHeight and other scaling operations that refer to container/line size\n      // can only be realized after all container scaling has been done\n      let h = node.y1;\n      \n      // if element spans height of its container/line, calculate new height\n      if (node.parent && spanHeight(node)) {\n        h = getOwnLine(node).height;\n        \n        const parentLines = getLines(node.parent);\n        const lineIndex = getLineIndex(node, parentLines);\n  \n        h -= !edgeMargins && lineIndex === 0 ? 0 : margin(node).top;\n        h -= !edgeMargins && lineIndex === (parentLines.length-1) ? 0 : margin(node).bottom;\n        \n        // now adjust the line heights accordingly by distributing the excess height\n        const heightDiff = h - node.y1;\n        console.log('y1:'+node.y1 + ' h:'+h+' diff:'+heightDiff);\n        if (isContainer(node) && node.children && heightDiff > 0) {\n          const lines = getLines(node);\n          console.log(lines);\n          \n          const excess = heightDiff / lines.length;\n          for (const line of lines) {\n            line.height += excess;\n          }\n        }\n      }\n      \n      node.y1 = h;\n    }\n    \n    function positionNode(node) {    \n      const w = node.x1 - node.x0;\n      const h = node.y1 - node.y0;\n      \n      if (node.parent) {      \n        // y-position children relative to parent container y + padding\n        node.y0 = node.parent.y0 + padding(node.parent).top;\n        \n        const order = node.parent.children.indexOf(node);\n        if (order === 0 || lineBreak(node)) {\n          // x-position 1. children (of line) relative to parent container x + padding\n          node.x0 += node.parent.x0 + padding(node.parent).left;\n          if (edgeMargins) node.x0 += margin(node).left;\n        }\n        else {\n          // all subsequent children can be x-positioned relative to their left neighbour\n          const neighbourLeft = node.parent.children[order-1];\n          node.x0 = neighbourLeft.x1;\n          // margins of both children are collapsed to the max value\n          node.x0 += Math.max( margin(neighbourLeft).right, margin(node).left );\n        }\n      } // if no parent, position is dependent only on vertical alignment\n      else {\n        switch (vAlign) {\n          case 'top':\n            node.y0 = 0;\n            break;\n          case 'middle':\n            node.y0 = h/2;\n            break;\n          case 'bottom':\n            node.y0 = h;\n            break;\n        }\n      }\n      \n      // shift height in middle and bottom alignments\n      // for children, add vertical margins and also shift to the y-position of their line\n      switch (vAlign) {\n        case 'top':\n          if (node.parent) {\n            const lineIndex = getLineIndex(node);\n            node.y0 += !edgeMargins && lineIndex === 0 ? 0 : margin(node).top;\n            node.y0 += calcLineShift(node);\n          }\n          break;\n        case 'middle':\n          if (node.parent) node.y0 += calcLineShift(node) + getOwnLine(node).height/2;\n          node.y0 -= h/2;\n          break;\n        case 'bottom':\n          if (node.parent) {\n            const lines = getLines(node.parent), lineIndex = getLineIndex(node, lines);\n            node.y0 -= !edgeMargins && lineIndex === (lines.length-1) ? 0 : margin(node).bottom;\n            node.y0 += calcLineShift(node, true);\n          }\n          node.y0 -= h;\n          break;\n      } \n      \n      // last, assign w/h shift to coordinates\n      node.x1 = node.x0 + w; \n      node.y1 = node.y0 + h;\n      \n    } // ------ end positionNode() -------\n    \n    // -------------------\n    // Essential functions\n    \n    function generateLines(node) {\n      const lines = [];\n      let lineWidth = 0, flexHeight = false, startIndex = 0, newLine = true;\n      node.children.forEach( (child,i) => {\n        // determine if at least one of the children in a line has a property to span container height\n        if (spanHeight(child) && !flexHeight) flexHeight = true;\n        \n        // add width of each child\n        lineWidth += (child.x1 - child.x0);\n  \n        // add largest of the two margins between children and left outer margin (if edgeMargins true)\n        lineWidth += newLine ? (edgeMargins ? margin(child).left : 0) : \n        Math.max(margin(child).left, margin(node.children[i-1]).right);\n        // right margin is only added at the end of a line (if edgeMargins true)\n        const marginRight = edgeMargins ? margin(child).right : 0;\n        if (lineWidth + marginRight > maxLineWidth(node) || i === node.children.length-1) \n          lineWidth += marginRight;\n  \n        // line breaks if maxLineWidth is surpassed or it's the last one\n        if (lineWidth > maxLineWidth(node) || i === node.children.length-1) {\n          // if true, add child interval to lines array and save line width\n          lines.push({from: startIndex, to: i, width: lineWidth, flexHeight: flexHeight});\n          // if not last line, reset variables\n          if (i < node.children.length-1) startIndex = i+1, lineWidth = 0, flexHeight = false, newLine = true;\n        }\n        else newLine = false;\n      });\n      return lines;\n    }\n    \n    function calcLineHeight(node, lines, lineIndex) {\n      const line = lines[lineIndex];\n      let lineHeight = 0;\n      \n      for (let i = line.from; i <= line.to; i++) {\n        const child = node.children[i];\n        // calculate the raw children height\n        const childH = child.y1 - child.y0;\n        // add vertical margins between children and (if edgeMargins true) outer vertical margins\n        // note: collapsing individual vertical margins is too messy and complicated, so I left this out\n        const marginsVert = (!edgeMargins && lineIndex===0 ? 0 : \n                             margin(child).top) +\n              (!edgeMargins && lineIndex===(lines.length-1) ? 0 : \n               margin(child).bottom);\n        // set line height if it surpasses line height of previous childs\n        if (childH + marginsVert > lineHeight) lineHeight = childH + marginsVert;\n      }\n      return Math.max(lineHeight, minContainerSize(node).height);\n    }\n    \n    // ----------------\n    // Helper functions\n      \n    function getLines(node) {\n      return lineMap[lineMap.findIndex(m => m.box === node)].lines;\n    }\n    \n    function getLineIndex(node, parentLines) {\n      if (node.parent) {\n        const lines = (arguments.length > 1) ? parentLines : getLines(node.parent);\n        const index = node.parent.children.indexOf(node);\n        \n        return lines.findIndex(l => { return (index >= l.from) && (index <= l.to); });\n      }\n      return null;\n    }\n    \n    function getOwnLine(node) {\n      const lines = getLines(node.parent);\n      const lineIndex = getLineIndex(node, lines);\n      return lines[lineIndex];\n    }\n    \n    function calcLineShift(node, include = false) {\n      if (node.parent) {      \n        const lines = getLines(node.parent);\n        const lineIndex = getLineIndex(node, lines);\n        const lineTo = include ? lineIndex : lineIndex-1;\n        \n        return d3.sum(lines.filter( (l,i) => (i <= lineTo) ), l => l.height);\n      }\n      return null;\n    }\n    \n    function lineBreak(node) {\n      if (node.parent) { \n        const index = node.parent.children.indexOf(node);\n        const lines = getLines(node.parent);\n        const line = lines[getLineIndex(node, lines)];\n        return line.from === index;\n      }\n      return null;\n    }\n  \n    function constant(x) { // from D3 source\n      return function() {\n        return x;\n      };\n    }\n                     \n    return compute;\n  }"],"sourceRoot":""}